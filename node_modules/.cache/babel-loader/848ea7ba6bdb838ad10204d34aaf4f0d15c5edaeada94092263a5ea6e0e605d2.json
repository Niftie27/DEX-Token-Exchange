{"ast":null,"code":"import { createSelector } from 'reselect';\nimport { get, groupBy, reject, maxBy, minBy } from 'lodash';\nimport moment from 'moment';\nimport { ethers } from 'ethers';\nconst GREEN = '#25CE8F';\nconst RED = '#F45353';\nconst account = state => get(state, 'provider.account');\nconst tokens = state => get(state, 'tokens.contracts');\nconst events = state => get(state, 'exchange.events');\nconst allOrders = state => get(state, 'exchange.allOrders.data', []);\nconst cancelledOrders = state => get(state, 'exchange.cancelledOrders.data', []);\nconst filledOrders = state => get(state, 'exchange.filledOrders.data', []);\nconst openOrders = state => {\n  const all = allOrders(state);\n  const filled = filledOrders(state);\n  const cancelled = cancelledOrders(state);\n  const openOrders = reject(all, order => {\n    const orderFilled = filled.some(o => o.id.toString() === order.id.toString());\n    const orderCancelled = cancelled.some(o => o.id.toString() === order.id.toString());\n    return orderFilled || orderCancelled;\n  });\n  return openOrders;\n};\n\n// ------------------------------------------------------------------------------\n// MY EVENTS\n\nexport const myEventsSelector = createSelector(account, events, (account, events) => {\n  events = events.filter(e => e.args.user === account);\n  console.log(events);\n  return events;\n});\n\n// ------------------------------------------------------------------------------\n// MY OPEN ORDERS\n\nexport const myOpenOrdersSelector = createSelector(account, tokens, openOrders, (account, tokens, orders) => {\n  if (!tokens[0] || !tokens[1]) {\n    return;\n  }\n\n  // Filter orders created by current account\n  orders = orders.filter(o => o.user === account);\n\n  // Filter orders by token addresses\n  orders = orders.filter(o => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address);\n  orders = orders.filter(o => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address);\n\n  // Decorate orders - add display attributes\n  orders = decorateMyOpenOrders(orders, tokens);\n\n  // Sort orders by date descending\n  orders = orders.sort((a, b) => b.timestamp - a.timestamp);\n  return orders;\n});\nconst decorateMyOpenOrders = (orders, tokens) => {\n  return orders.map(order => {\n    order = decorateOrder(order, tokens);\n    order = decorateMyOpenOrder(order, tokens);\n    return order;\n  });\n};\nconst decorateMyOpenOrder = (order, tokens) => {\n  let orderType = order.tokenGive === tokens[1].address ? 'buy' : 'sell';\n  return {\n    ...order,\n    orderType,\n    orderTypeClass: orderType === 'buy' ? GREEN : RED\n  };\n};\nconst decorateOrder = (order, tokens) => {\n  let token0Amount, token1Amount;\n\n  // Note: DApp should be considered token0, mETH is considered token1\n  // Example: Giving mETH in exchange for DApp\n  if (order.tokenGive === tokens[1].address) {\n    token0Amount = order.amountGive; // The amount of DApp we are giving\n    token1Amount = order.amountGet; // The amount of mETH we want...\n  } else {\n    token0Amount = order.amountGet; // The amount of DApp we want\n    token1Amount = order.amountGive; // The amount of mETH we are giving...\n  }\n\n  // Calculate token price to 5 decimal places\n  const precision = 100000;\n  let tokenPrice = token1Amount / token0Amount;\n  tokenPrice = Math.round(tokenPrice * precision) / precision;\n  return {\n    ...order,\n    token1Amount: ethers.utils.formatUnits(token1Amount, \"ether\"),\n    token0Amount: ethers.utils.formatUnits(token0Amount, \"ether\"),\n    tokenPrice,\n    formattedTimestamp: moment.unix(order.timestamp).format('h:mm:ssa d MMM D')\n  };\n};\n\n// ------------------------------------------------------------------------------\n// ALL FILLED ORDERS\n\nexport const filledOrdersSelector = createSelector(filledOrders, tokens, (orders, tokens) => {\n  if (!tokens[0] || !tokens[1]) {\n    return;\n  }\n\n  // Filter orders by selected tokens\n  orders = orders.filter(o => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address);\n  orders = orders.filter(o => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address);\n\n  // Sort orders by time ascending for price comparison\n  orders = orders.sort((a, b) => a.timestamp - b.timestamp);\n\n  // Decorate the orders\n  orders = decorateFilledOrders(orders, tokens);\n\n  // Sort orders by date descending for display\n  orders = orders.sort((a, b) => b.timestamp - a.timestamp);\n  return orders;\n});\nconst decorateFilledOrders = (orders, tokens) => {\n  // Track previous order to compare history\n  let previousOrder = orders[0];\n  return orders.map(order => {\n    // decorate each individual order\n    order = decorateOrder(order, tokens);\n    order = decorateFilledOrder(order, previousOrder);\n    previousOrder = order; // Update the previous order once it's decorated\n    return order;\n  });\n};\nconst decorateFilledOrder = (order, previousOrder) => {\n  return {\n    ...order,\n    tokenPriceClass: tokenPriceClass(order.tokenPrice, order.id, previousOrder)\n  };\n};\nconst tokenPriceClass = (tokenPrice, orderId, previousOrder) => {\n  // Show green price if only one order exists\n  if (previousOrder.id === orderId) {\n    return GREEN;\n  }\n\n  // Show green price if order price higher than previous order\n  // Show red price if order price lower than previous order\n  if (previousOrder.tokenPrice <= tokenPrice) {\n    return GREEN; // success\n  } else {\n    return RED; // danger\n  }\n};\n\n// ------------------------------------------------------------------------------\n// MY FILLED ORDERS\n\nexport const myFilledOrdersSelector = createSelector(account, tokens, filledOrders, (account, tokens, orders) => {\n  if (!tokens[0] || !tokens[1]) {\n    return;\n  }\n\n  // Find our orders\n  orders = orders.filter(o => o.user === account || o.creator === account);\n  // Filter orders for current trading pair\n  orders = orders.filter(o => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address);\n  orders = orders.filter(o => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address);\n\n  // Sort by date descending\n  orders = orders.sort((a, b) => b.timestamp - a.timestamp);\n\n  // Decorate orders - add display attributes\n  orders = decorateMyFilledOrders(orders, account, tokens);\n  return orders;\n});\nconst decorateMyFilledOrders = (orders, account, tokens) => {\n  return orders.map(order => {\n    order = decorateOrder(order, tokens);\n    order = decorateMyFilledOrder(order, account, tokens);\n    return order;\n  });\n};\nconst decorateMyFilledOrder = (order, account, tokens) => {\n  const myOrder = order.creator === account;\n  let orderType;\n  if (myOrder) {\n    orderType = order.tokenGive === tokens[1].address ? 'buy' : 'sell';\n  } else {\n    orderType = order.tokenGive === tokens[1].address ? 'sell' : 'buy';\n  }\n  return {\n    ...order,\n    orderType,\n    orderClass: orderType === 'buy' ? GREEN : RED,\n    orderSign: orderType === 'buy' ? '+' : '-'\n  };\n};\n\n// ------------------------------------------------------------------------------\n// ORDER BOOK\n\nexport const orderBookSelector = createSelector(openOrders, tokens, (orders, tokens) => {\n  if (!tokens[0] || !tokens[1]) {\n    return;\n  }\n\n  // Filter orders by selected tokens\n  orders = orders.filter(o => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address);\n  orders = orders.filter(o => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address);\n\n  // Decorate orders\n  orders = decorateOrderBookOrders(orders, tokens);\n\n  // Group orders by \"orderType\"\n  orders = groupBy(orders, 'orderType');\n\n  // Fetch buy orders\n  const buyOrders = get(orders, 'buy', []);\n\n  // Sort buy orders by token price\n  orders = {\n    ...orders,\n    buyOrders: buyOrders.sort((a, b) => b.tokenPrice - a.tokenPrice)\n  };\n\n  // Fetch sell orders\n  const sellOrders = get(orders, 'sell', []);\n\n  // Sort sell orders by token price\n  orders = {\n    ...orders,\n    sellOrders: sellOrders.sort((a, b) => b.tokenPrice - a.tokenPrice)\n  };\n  return orders;\n});\nconst decorateOrderBookOrders = (orders, tokens) => {\n  return orders.map(order => {\n    order = decorateOrder(order, tokens);\n    order = decorateOrderBookOrder(order, tokens);\n    return order;\n  });\n};\nconst decorateOrderBookOrder = (order, tokens) => {\n  const orderType = order.tokenGive === tokens[1].address ? 'buy' : 'sell';\n  return {\n    ...order,\n    orderType,\n    orderTypeClass: orderType === 'buy' ? GREEN : RED,\n    orderFillAction: orderType === 'buy' ? 'sell' : 'buy'\n  };\n};\n\n// ------------------------------------------------------------------------------\n// PRICE CHART\n\nexport const priceChartSelector = createSelector(filledOrders, tokens, (orders, tokens) => {\n  if (!tokens[0] || !tokens[1]) {\n    return;\n  }\n\n  // Filter orders by selected tokens\n  orders = orders.filter(o => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address);\n  orders = orders.filter(o => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address);\n\n  // Sort orders by date ascending to compare history\n  orders = orders.sort((a, b) => a.timestamp - b.timestamp);\n\n  // Decorate orders - add display attributes\n  orders = orders.map(o => decorateOrder(o, tokens));\n\n  // Get last 2 order for final price & price change\n  let secondLastOrder, lastOrder;\n  [secondLastOrder, lastOrder] = orders.slice(orders.length - 2, orders.length);\n\n  // get last order price\n  const lastPrice = get(lastOrder, 'tokenPrice', 0);\n\n  // get second last order price\n  const secondLastPrice = get(secondLastOrder, 'tokenPrice', 0);\n  return {\n    lastPrice,\n    lastPriceChange: lastPrice >= secondLastPrice ? '+' : '-',\n    series: [{\n      data: buildGraphData(orders)\n    }]\n  };\n});\nconst buildGraphData = orders => {\n  // Group the orders by hour for the graph\n  orders = groupBy(orders, o => moment.unix(o.timestamp).startOf('hour').format());\n\n  // Get each hour where data exists\n  const hours = Object.keys(orders);\n\n  // Build the graph series\n  const graphData = hours.map(hour => {\n    // Fetch all orders from current hour\n    const group = orders[hour];\n\n    // Calculate price values: open, high, low, close\n    const open = group[0]; // first order\n    const high = maxBy(group, 'tokenPrice'); // high price\n    const low = minBy(group, 'tokenPrice'); // low price\n    const close = group[group.length - 1]; // last order\n\n    return {\n      x: new Date(hour),\n      y: [open.tokenPrice, high.tokenPrice, low.tokenPrice, close.tokenPrice]\n    };\n  });\n  return graphData;\n};","map":{"version":3,"names":["createSelector","get","groupBy","reject","maxBy","minBy","moment","ethers","GREEN","RED","account","state","tokens","events","allOrders","cancelledOrders","filledOrders","openOrders","all","filled","cancelled","order","orderFilled","some","o","id","toString","orderCancelled","myEventsSelector","filter","e","args","user","console","log","myOpenOrdersSelector","orders","tokenGet","address","tokenGive","decorateMyOpenOrders","sort","a","b","timestamp","map","decorateOrder","decorateMyOpenOrder","orderType","orderTypeClass","token0Amount","token1Amount","amountGive","amountGet","precision","tokenPrice","Math","round","utils","formatUnits","formattedTimestamp","unix","format","filledOrdersSelector","decorateFilledOrders","previousOrder","decorateFilledOrder","tokenPriceClass","orderId","myFilledOrdersSelector","creator","decorateMyFilledOrders","decorateMyFilledOrder","myOrder","orderClass","orderSign","orderBookSelector","decorateOrderBookOrders","buyOrders","sellOrders","decorateOrderBookOrder","orderFillAction","priceChartSelector","secondLastOrder","lastOrder","slice","length","lastPrice","secondLastPrice","lastPriceChange","series","data","buildGraphData","startOf","hours","Object","keys","graphData","hour","group","open","high","low","close","x","Date","y"],"sources":["/home/tomas/code/blockchain-developer-bootcamp_legacy_version/src/store/selectors.js"],"sourcesContent":["import { createSelector } from 'reselect'\r\nimport { get, groupBy, reject, maxBy, minBy } from 'lodash';\r\nimport moment from 'moment'\r\nimport { ethers } from 'ethers';\r\n\r\nconst GREEN = '#25CE8F'\r\nconst RED = '#F45353'\r\n\r\n\r\nconst account = state => get(state, 'provider.account')\r\nconst tokens = state => get(state, 'tokens.contracts')\r\nconst events = state => get(state, 'exchange.events')\r\n\r\nconst allOrders = state => get(state, 'exchange.allOrders.data', [])\r\nconst cancelledOrders = state => get(state, 'exchange.cancelledOrders.data', [])\r\nconst filledOrders = state => get(state, 'exchange.filledOrders.data', [])\r\n\r\nconst openOrders = state => {\r\n  const all = allOrders(state)\r\n  const filled = filledOrders(state)\r\n  const cancelled = cancelledOrders(state)\r\n\r\n  const openOrders = reject(all, (order) => {\r\n    const orderFilled = filled.some((o) => o.id.toString() === order.id.toString())\r\n    const orderCancelled = cancelled.some((o) => o.id.toString() === order.id.toString())\r\n    return(orderFilled || orderCancelled)\r\n  })\r\n\r\n  return openOrders\r\n\r\n}\r\n\r\n// ------------------------------------------------------------------------------\r\n// MY EVENTS\r\n\r\nexport const myEventsSelector = createSelector(\r\n  account,\r\n  events,\r\n  (account, events) => {\r\n    events = events.filter((e) => e.args.user === account)\r\n    console.log(events)\r\n    return events\r\n  }\r\n)\r\n\r\n// ------------------------------------------------------------------------------\r\n// MY OPEN ORDERS\r\n\r\nexport const myOpenOrdersSelector = createSelector(\r\n    account,\r\n    tokens,\r\n    openOrders,\r\n    (account, tokens, orders) => {\r\n      if (!tokens[0] || !tokens[1]) { return }\r\n\r\n      // Filter orders created by current account\r\n      orders = orders.filter((o) => o.user === account)\r\n\r\n      // Filter orders by token addresses\r\n      orders = orders.filter((o) => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address)\r\n      orders = orders.filter((o) => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address)\r\n\r\n      // Decorate orders - add display attributes\r\n      orders = decorateMyOpenOrders(orders, tokens)\r\n\r\n      // Sort orders by date descending\r\n      orders = orders.sort((a, b) => b.timestamp - a.timestamp)\r\n\r\n      return orders\r\n  }\r\n)\r\n\r\nconst decorateMyOpenOrders = (orders, tokens) => {\r\n  return(\r\n    orders.map((order) => {\r\n      order = decorateOrder(order, tokens)\r\n      order = decorateMyOpenOrder(order, tokens)\r\n      return(order)\r\n    })\r\n  )\r\n}\r\n\r\nconst decorateMyOpenOrder = (order, tokens) => {\r\n  let orderType = order.tokenGive === tokens[1].address ? 'buy' : 'sell'\r\n\r\n  return({\r\n    ...order,\r\n    orderType,\r\n    orderTypeClass: (orderType === 'buy' ? GREEN : RED)\r\n  })\r\n}\r\n\r\nconst decorateOrder = (order, tokens) => {\r\n  let token0Amount, token1Amount\r\n\r\n  // Note: DApp should be considered token0, mETH is considered token1\r\n  // Example: Giving mETH in exchange for DApp\r\n  if (order.tokenGive === tokens[1].address) {\r\n    token0Amount = order.amountGive // The amount of DApp we are giving\r\n    token1Amount = order.amountGet // The amount of mETH we want...\r\n  } else {\r\n    token0Amount = order.amountGet // The amount of DApp we want\r\n    token1Amount = order.amountGive // The amount of mETH we are giving...\r\n  }\r\n\r\n  // Calculate token price to 5 decimal places\r\n  const precision = 100000\r\n  let tokenPrice = (token1Amount / token0Amount)\r\n  tokenPrice = Math.round(tokenPrice * precision) / precision\r\n\r\n  return ({\r\n    ...order,\r\n    token1Amount: ethers.utils.formatUnits(token1Amount, \"ether\"),\r\n    token0Amount: ethers.utils.formatUnits(token0Amount, \"ether\"),\r\n    tokenPrice,\r\n    formattedTimestamp: moment.unix(order.timestamp).format('h:mm:ssa d MMM D')\r\n  })\r\n}\r\n\r\n\r\n// ------------------------------------------------------------------------------\r\n// ALL FILLED ORDERS\r\n\r\nexport const filledOrdersSelector = createSelector(\r\n  filledOrders,\r\n  tokens,\r\n  (orders, tokens) => {\r\n    if (!tokens[0] || !tokens[1]) { return }\r\n\r\n    // Filter orders by selected tokens\r\n    orders = orders.filter((o) => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address)\r\n    orders = orders.filter((o) => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address)\r\n\r\n    // Sort orders by time ascending for price comparison\r\n    orders = orders.sort((a, b) => a.timestamp - b.timestamp)\r\n\r\n    // Decorate the orders\r\n    orders = decorateFilledOrders(orders, tokens)\r\n\r\n    // Sort orders by date descending for display\r\n    orders = orders.sort((a, b) => b.timestamp - a.timestamp)\r\n\r\n    return orders\r\n\r\n  }\r\n)\r\n\r\nconst decorateFilledOrders = (orders, tokens) => {\r\n  // Track previous order to compare history\r\n  let previousOrder = orders[0]\r\n\r\n  return(\r\n    orders.map((order) => {\r\n      // decorate each individual order\r\n      order = decorateOrder(order, tokens)\r\n      order = decorateFilledOrder(order, previousOrder)\r\n      previousOrder = order  // Update the previous order once it's decorated\r\n      return order\r\n    })\r\n  )\r\n}\r\n\r\nconst decorateFilledOrder = (order, previousOrder) => {\r\n  return({\r\n    ...order,\r\n    tokenPriceClass: tokenPriceClass(order.tokenPrice, order.id, previousOrder)\r\n  })\r\n}\r\n\r\nconst tokenPriceClass = (tokenPrice, orderId, previousOrder) => {\r\n  // Show green price if only one order exists\r\n  if (previousOrder.id === orderId) {\r\n    return GREEN\r\n  }\r\n\r\n  // Show green price if order price higher than previous order\r\n  // Show red price if order price lower than previous order\r\n  if (previousOrder.tokenPrice <= tokenPrice) {\r\n    return GREEN // success\r\n  } else {\r\n    return RED // danger\r\n  }\r\n}\r\n\r\n// ------------------------------------------------------------------------------\r\n// MY FILLED ORDERS\r\n\r\nexport const myFilledOrdersSelector = createSelector(\r\n    account,\r\n    tokens,\r\n    filledOrders,\r\n    (account, tokens, orders) => {\r\n      if (!tokens[0] || !tokens[1]) { return }\r\n\r\n      // Find our orders\r\n      orders = orders.filter((o) => o.user === account || o.creator === account)\r\n      // Filter orders for current trading pair\r\n      orders = orders.filter((o) => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address)\r\n      orders = orders.filter((o) => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address)\r\n\r\n      // Sort by date descending\r\n      orders = orders.sort((a, b) => b.timestamp - a.timestamp)\r\n\r\n      // Decorate orders - add display attributes\r\n      orders = decorateMyFilledOrders(orders, account, tokens)\r\n\r\n      return orders\r\n  }\r\n)\r\n\r\nconst decorateMyFilledOrders = (orders, account, tokens) => {\r\n  return(\r\n    orders.map((order) => {\r\n      order = decorateOrder(order, tokens)\r\n      order = decorateMyFilledOrder(order, account, tokens)\r\n      return(order)\r\n    })\r\n  )\r\n}\r\n\r\nconst decorateMyFilledOrder = (order, account, tokens) => {\r\n  const myOrder = order.creator === account\r\n\r\n  let orderType\r\n  if(myOrder) {\r\n    orderType = order.tokenGive === tokens[1].address ? 'buy' : 'sell'\r\n  } else {\r\n    orderType = order.tokenGive === tokens[1].address ? 'sell' : 'buy'\r\n  }\r\n\r\n  return({\r\n    ...order,\r\n    orderType,\r\n    orderClass: (orderType === 'buy' ? GREEN : RED),\r\n    orderSign: (orderType === 'buy' ? '+' : '-')\r\n  })\r\n}\r\n\r\n\r\n// ------------------------------------------------------------------------------\r\n// ORDER BOOK\r\n\r\nexport const orderBookSelector = createSelector(\r\n  openOrders,\r\n  tokens,\r\n  (orders, tokens) => {\r\n    if (!tokens[0] || !tokens[1]) { return }\r\n\r\n    // Filter orders by selected tokens\r\n    orders = orders.filter((o) => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address)\r\n    orders = orders.filter((o) => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address)\r\n\r\n    // Decorate orders\r\n    orders = decorateOrderBookOrders(orders, tokens)\r\n\r\n    // Group orders by \"orderType\"\r\n    orders = groupBy(orders, 'orderType')\r\n\r\n    // Fetch buy orders\r\n    const buyOrders = get(orders, 'buy', [])\r\n\r\n    // Sort buy orders by token price\r\n     orders = {\r\n        ...orders,\r\n        buyOrders: buyOrders.sort((a, b) => b.tokenPrice - a.tokenPrice)\r\n      }\r\n\r\n    // Fetch sell orders\r\n    const sellOrders = get(orders, 'sell', [])\r\n\r\n    // Sort sell orders by token price\r\n    orders = {\r\n      ...orders,\r\n      sellOrders: sellOrders.sort((a, b) => b.tokenPrice - a.tokenPrice)\r\n    }\r\n\r\n    return orders\r\n  }\r\n)\r\n\r\nconst decorateOrderBookOrders = (orders, tokens) => {\r\n  return(\r\n    orders.map((order) => {\r\n      order = decorateOrder(order, tokens)\r\n      order = decorateOrderBookOrder(order, tokens)\r\n      return(order)\r\n    })\r\n  )\r\n}\r\n\r\nconst decorateOrderBookOrder = (order, tokens) => {\r\n  const orderType = order.tokenGive === tokens[1].address ? 'buy' : 'sell'\r\n\r\n  return({\r\n    ...order,\r\n    orderType,\r\n    orderTypeClass: (orderType === 'buy' ? GREEN : RED),\r\n    orderFillAction: (orderType === 'buy' ? 'sell' : 'buy')\r\n  })\r\n}\r\n\r\n\r\n// ------------------------------------------------------------------------------\r\n// PRICE CHART\r\n\r\nexport const priceChartSelector = createSelector(\r\n  filledOrders,\r\n  tokens,\r\n  (orders, tokens) => {\r\n    if (!tokens[0] || !tokens[1]) { return }\r\n\r\n    // Filter orders by selected tokens\r\n    orders = orders.filter((o) => o.tokenGet === tokens[0].address || o.tokenGet === tokens[1].address)\r\n    orders = orders.filter((o) => o.tokenGive === tokens[0].address || o.tokenGive === tokens[1].address)\r\n\r\n    // Sort orders by date ascending to compare history\r\n    orders = orders.sort((a, b) => a.timestamp - b.timestamp)\r\n\r\n    // Decorate orders - add display attributes\r\n    orders = orders.map((o) => decorateOrder(o, tokens))\r\n\r\n    // Get last 2 order for final price & price change\r\n    let secondLastOrder, lastOrder\r\n    [secondLastOrder, lastOrder] = orders.slice(orders.length - 2, orders.length)\r\n\r\n    // get last order price\r\n    const lastPrice = get(lastOrder, 'tokenPrice', 0)\r\n\r\n    // get second last order price\r\n    const secondLastPrice = get(secondLastOrder, 'tokenPrice', 0)\r\n\r\n    return ({\r\n      lastPrice,\r\n      lastPriceChange: (lastPrice >= secondLastPrice ? '+' : '-'),\r\n      series: [{\r\n        data: buildGraphData(orders)\r\n      }]\r\n    })\r\n\r\n  }\r\n)\r\n\r\nconst buildGraphData = (orders) => {\r\n  // Group the orders by hour for the graph\r\n  orders = groupBy(orders, (o) => moment.unix(o.timestamp).startOf('hour').format())\r\n\r\n  // Get each hour where data exists\r\n  const hours = Object.keys(orders)\r\n\r\n  // Build the graph series\r\n  const graphData = hours.map((hour) => {\r\n    // Fetch all orders from current hour\r\n    const group = orders[hour]\r\n\r\n    // Calculate price values: open, high, low, close\r\n    const open = group[0] // first order\r\n    const high = maxBy(group, 'tokenPrice') // high price\r\n    const low = minBy(group, 'tokenPrice') // low price\r\n    const close = group[group.length - 1] // last order\r\n\r\n    return({\r\n      x: new Date(hour),\r\n      y: [open.tokenPrice, high.tokenPrice, low.tokenPrice, close.tokenPrice]\r\n    })\r\n  })\r\n\r\n  return graphData\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}